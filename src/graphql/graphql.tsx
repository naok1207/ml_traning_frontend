import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'

export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: string
}

/** Mutation */
export type Mutation = {
  __typename?: 'Mutation'
  createTask?: Maybe<TaskCreatePayload>
  deleteTask?: Maybe<TaskDeletePayload>
  updateTask?: Maybe<TaskUpdatePayload>
}

/** Mutation */
export type MutationCreateTaskArgs = {
  input: TaskCreateInput
}

/** Mutation */
export type MutationDeleteTaskArgs = {
  input: TaskDeleteInput
}

/** Mutation */
export type MutationUpdateTaskArgs = {
  input: TaskUpdateInput
}

/** Query */
export type Query = {
  __typename?: 'Query'
  task: Task
  tasks: Array<Task>
}

/** Query */
export type QueryTaskArgs = {
  id: Scalars['ID']
}

export type Task = {
  __typename?: 'Task'
  createdAt: Scalars['ISO8601DateTime']
  description?: Maybe<Scalars['String']>
  id: Scalars['ID']
  status: Scalars['Int']
  title: Scalars['String']
  updatedAt: Scalars['ISO8601DateTime']
}

export type TaskAttributes = {
  description?: InputMaybe<Scalars['String']>
  title: Scalars['String']
}

/** Autogenerated input type of TaskCreate */
export type TaskCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  params: TaskAttributes
}

/** Autogenerated return type of TaskCreate */
export type TaskCreatePayload = {
  __typename?: 'TaskCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  task: Task
}

/** Autogenerated input type of TaskDelete */
export type TaskDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of TaskDelete */
export type TaskDeletePayload = {
  __typename?: 'TaskDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated input type of TaskUpdate */
export type TaskUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['ID']
  params: TaskAttributes
}

/** Autogenerated return type of TaskUpdate */
export type TaskUpdatePayload = {
  __typename?: 'TaskUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  task: Task
}

export type CreateTaskMutationVariables = Exact<{
  params: TaskAttributes
}>

export type CreateTaskMutation = {
  __typename?: 'Mutation'
  createTask?: {
    __typename?: 'TaskCreatePayload'
    task: {
      __typename?: 'Task'
      createdAt: string
      description?: string | null
      id: string
      status: number
      title: string
      updatedAt: string
    }
  } | null
}

export type DeleteTaskMutationVariables = Exact<{
  input: TaskDeleteInput
}>

export type DeleteTaskMutation = {
  __typename?: 'Mutation'
  deleteTask?: {
    __typename?: 'TaskDeletePayload'
    id: string
    clientMutationId?: string | null
  } | null
}

export type UpdateTaskMutationVariables = Exact<{
  input: TaskUpdateInput
}>

export type UpdateTaskMutation = {
  __typename?: 'Mutation'
  updateTask?: {
    __typename?: 'TaskUpdatePayload'
    task: {
      __typename?: 'Task'
      createdAt: string
      description?: string | null
      id: string
      status: number
      title: string
      updatedAt: string
    }
  } | null
}

export type TaskQueryVariables = Exact<{
  taskId: Scalars['ID']
}>

export type TaskQuery = {
  __typename?: 'Query'
  task: {
    __typename?: 'Task'
    createdAt: string
    description?: string | null
    id: string
    status: number
    title: string
    updatedAt: string
  }
}

export type TasksQueryVariables = Exact<{ [key: string]: never }>

export type TasksQuery = {
  __typename?: 'Query'
  tasks: Array<{
    __typename?: 'Task'
    createdAt: string
    description?: string | null
    id: string
    status: number
    title: string
    updatedAt: string
  }>
}

export const CreateTaskDocument = gql`
  mutation createTask($params: TaskAttributes!) {
    createTask(input: { params: $params }) {
      task {
        createdAt
        description
        id
        status
        title
        updatedAt
      }
    }
  }
`
export type CreateTaskMutationFn = Apollo.MutationFunction<
  CreateTaskMutation,
  CreateTaskMutationVariables
>

/**
 * __useCreateTaskMutation__
 *
 * To run a mutation, you first call `useCreateTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTaskMutation, { data, loading, error }] = useCreateTaskMutation({
 *   variables: {
 *      params: // value for 'params'
 *   },
 * });
 */
export function useCreateTaskMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateTaskMutation,
    CreateTaskMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateTaskMutation, CreateTaskMutationVariables>(
    CreateTaskDocument,
    options
  )
}
export type CreateTaskMutationHookResult = ReturnType<
  typeof useCreateTaskMutation
>
export type CreateTaskMutationResult = Apollo.MutationResult<CreateTaskMutation>
export type CreateTaskMutationOptions = Apollo.BaseMutationOptions<
  CreateTaskMutation,
  CreateTaskMutationVariables
>
export const DeleteTaskDocument = gql`
  mutation deleteTask($input: TaskDeleteInput!) {
    deleteTask(input: $input) {
      id
      clientMutationId
    }
  }
`
export type DeleteTaskMutationFn = Apollo.MutationFunction<
  DeleteTaskMutation,
  DeleteTaskMutationVariables
>

/**
 * __useDeleteTaskMutation__
 *
 * To run a mutation, you first call `useDeleteTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTaskMutation, { data, loading, error }] = useDeleteTaskMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTaskMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteTaskMutation,
    DeleteTaskMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteTaskMutation, DeleteTaskMutationVariables>(
    DeleteTaskDocument,
    options
  )
}
export type DeleteTaskMutationHookResult = ReturnType<
  typeof useDeleteTaskMutation
>
export type DeleteTaskMutationResult = Apollo.MutationResult<DeleteTaskMutation>
export type DeleteTaskMutationOptions = Apollo.BaseMutationOptions<
  DeleteTaskMutation,
  DeleteTaskMutationVariables
>
export const UpdateTaskDocument = gql`
  mutation UpdateTask($input: TaskUpdateInput!) {
    updateTask(input: $input) {
      task {
        createdAt
        description
        id
        status
        title
        updatedAt
      }
    }
  }
`
export type UpdateTaskMutationFn = Apollo.MutationFunction<
  UpdateTaskMutation,
  UpdateTaskMutationVariables
>

/**
 * __useUpdateTaskMutation__
 *
 * To run a mutation, you first call `useUpdateTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTaskMutation, { data, loading, error }] = useUpdateTaskMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTaskMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateTaskMutation,
    UpdateTaskMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateTaskMutation, UpdateTaskMutationVariables>(
    UpdateTaskDocument,
    options
  )
}
export type UpdateTaskMutationHookResult = ReturnType<
  typeof useUpdateTaskMutation
>
export type UpdateTaskMutationResult = Apollo.MutationResult<UpdateTaskMutation>
export type UpdateTaskMutationOptions = Apollo.BaseMutationOptions<
  UpdateTaskMutation,
  UpdateTaskMutationVariables
>
export const TaskDocument = gql`
  query Task($taskId: ID!) {
    task(id: $taskId) {
      createdAt
      description
      id
      status
      title
      updatedAt
    }
  }
`

/**
 * __useTaskQuery__
 *
 * To run a query within a React component, call `useTaskQuery` and pass it any options that fit your needs.
 * When your component renders, `useTaskQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTaskQuery({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useTaskQuery(
  baseOptions: Apollo.QueryHookOptions<TaskQuery, TaskQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TaskQuery, TaskQueryVariables>(TaskDocument, options)
}
export function useTaskLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TaskQuery, TaskQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TaskQuery, TaskQueryVariables>(
    TaskDocument,
    options
  )
}
export type TaskQueryHookResult = ReturnType<typeof useTaskQuery>
export type TaskLazyQueryHookResult = ReturnType<typeof useTaskLazyQuery>
export type TaskQueryResult = Apollo.QueryResult<TaskQuery, TaskQueryVariables>
export const TasksDocument = gql`
  query Tasks {
    tasks {
      createdAt
      description
      id
      status
      title
      updatedAt
    }
  }
`

/**
 * __useTasksQuery__
 *
 * To run a query within a React component, call `useTasksQuery` and pass it any options that fit your needs.
 * When your component renders, `useTasksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTasksQuery({
 *   variables: {
 *   },
 * });
 */
export function useTasksQuery(
  baseOptions?: Apollo.QueryHookOptions<TasksQuery, TasksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TasksQuery, TasksQueryVariables>(
    TasksDocument,
    options
  )
}
export function useTasksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TasksQuery, TasksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TasksQuery, TasksQueryVariables>(
    TasksDocument,
    options
  )
}
export type TasksQueryHookResult = ReturnType<typeof useTasksQuery>
export type TasksLazyQueryHookResult = ReturnType<typeof useTasksLazyQuery>
export type TasksQueryResult = Apollo.QueryResult<
  TasksQuery,
  TasksQueryVariables
>
